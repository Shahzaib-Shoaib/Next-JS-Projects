// # MemJS Memcache Client

var errors = require('./protocol').errors;
var Server = require('./server').Server;
var noopSerializer = require('./noop-serializer').noopSerializer;
var makeRequestBuffer = require('./utils').makeRequestBuffer;
var hashCode = require('./utils').hashCode;
var merge = require('./utils').merge;
var makeExpiration = require('./utils').makeExpiration;
var makeAmountInitialAndExpiration = require('./utils').makeAmountInitialAndExpiration;

// Client initializer takes a list of `Server`s and an `options` dictionary.
// See `Client.create` for details.
var Client = function(servers, options) {
  this.servers = servers;
  this.seq = 0;
  this.options = merge(options || {},
    {failoverTime: 60, retries: 2, retry_delay: 0.2, expires: 0, logger: console});

  this.serializer = this.options.serializer || noopSerializer;
};

// Creates a new client given an optional config string and optional hash of
// options. The config string should be of the form:
//
//     "[user:pass@]server1[:11211],[user:pass@]server2[:11211],..."
//
// If the argument is not given, fallback on the `MEMCACHIER_SERVERS` environment
// variable, `MEMCACHE_SERVERS` environment variable or `"localhost:11211"`.
//
// The options hash may contain the options:
//
// * `retries` - the number of times to retry an operation in lieu of failures
// (default 2)
// * `expires` - the default expiration in seconds to use (default 0 - never
// expire). If `expires` is greater than 30 days (60 x 60 x 24 x 30), it is
// treated as a UNIX time (number of seconds since January 1, 1970).
// * `logger` - a logger object that responds to `log(string)` method calls.
// * `failover` - whether to failover to next server. Defaults to false.
// * `failoverTime` - how much to wait until retring a failed server. Default
//                    is 60 seconds.
//
//   ~~~~
//     log(msg1[, msg2[, msg3[...]]])
//   ~~~~
//
//   Defaults to `console`.
// * `serializer` - the object which will (de)serialize the data. It needs
//   two public methods: serialize and deserialize. It defaults to the 
//   noopSerializer:
//
//   ~~~~
//   var noopSerializer = {
//     serialize: function (opcode, value, extras) {
//       return { value: value, extras: extras };
//     },
//     deserialize: function (opcode, value, extras) {
//       return { value: value, extras: extras };
//     }
//   };
//   ~~~~
//
// Or options for the servers including:
// * `username` and `password` for fallback SASL authentication credentials.
// * `timeout` in seconds to determine failure for operations. Default is 0.5
//             seconds.
// * 'conntimeout' in seconds to connection failure. Default is twice the value
//                 of `timeout`.
// * `keepAlive` whether to enable keep-alive functionality. Defaults to false.
// * `keepAliveDelay` in seconds to the initial delay before the first keepalive
//                    probe is sent on an idle socket. Defaults is 30 seconds.
Client.create = function(serversStr, options) {
  serversStr = serversStr || process.env.MEMCACHIER_SERVERS ||
                             process.env.MEMCACHE_SERVERS || 'localhost:11211';
  var serverUris = serversStr.split(',');
  var servers = serverUris.map(function(uri) {
    var uriParts = uri.split('@');
    var hostPort = uriParts[uriParts.length - 1].split(':');
    var userPass = (uriParts[uriParts.length - 2] || '').split(':');
    return new Server(hostPort[0], parseInt(hostPort[1] || 11211, 10), userPass[0], userPass[1], options);
  });
  return new Client(servers, options);
};

// Chooses the server to talk to by hashing the given key.
Client.prototype.server = function(key) {
  // TODO(alevy): should use consistent hashing and/or allow swapping hashing
  // mechanisms
  var total = this.servers.length;
  var origIdx = (total > 1) ? (hashCode(key) % total) : 0;
  var idx = origIdx;
  var serv = this.servers[idx];
  while (serv.wakeupAt &&
      serv.wakeupAt > Date.now()) {
    idx = (idx + 1) % total;
    if (idx === origIdx) {
      return null;
    }
    serv = this.servers[idx];
  }
  return serv;
};

// converts a call into a promise-returning one
var promisify = function(command) {
  return new Promise(function(resolve, reject) {
    command(function(err, result) {
      err ? reject(err) : resolve(result);
    });
  });
};

// ## Memcache Commands
//
// All commands return their results through a callback passed as the last
// required argument (some commands, like `Client#set`, take optional arguments
// after the callback).
//
// The callback signature always follows:
//
//     callback(err, [arg1[, arg2[, arg3[...]]]])
//
// In case of an error the _err_ argument will be non-null and contain the
// `Error`. A notable exception includes a `Client#get` on a key that doesn't
// exist. In this case, _err_ will be null, as will the _value and _extras_
// arguments.

// GET
//
// Retrieves the value at the given key in memcache.
//
// The callback signature is:
//
//     callback(err, value, flags)
//
// _value_ and _flags_ are both `Buffer`s. If the key is not found, the
// callback is invoked with null for both arguments and no error.
Client.prototype.get = function(key, callback) {
  var self = this;
  if(callback === undefined) {
    return promisify(function(callback) {
      self.get(key, function(err, value, flags) {
        callback(err, {value: value, flags: flags});
      });
    });
  }
  var logger = this.options.